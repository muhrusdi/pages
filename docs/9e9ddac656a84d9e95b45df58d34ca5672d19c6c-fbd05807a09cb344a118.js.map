{"version":3,"file":"9e9ddac656a84d9e95b45df58d34ca5672d19c6c-fbd05807a09cb344a118.js","mappings":"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","sources":["webpack://muhrusdi.github.io/./node_modules/@apollo/client/react/parser/index.js","webpack://muhrusdi.github.io/./node_modules/@apollo/client/react/data/OperationData.js","webpack://muhrusdi.github.io/./node_modules/@apollo/client/react/data/QueryData.js","webpack://muhrusdi.github.io/./node_modules/@apollo/client/react/hooks/utils/useBaseQuery.js","webpack://muhrusdi.github.io/./node_modules/@apollo/client/react/hooks/utils/useDeepMemo.js","webpack://muhrusdi.github.io/./node_modules/@apollo/client/react/hooks/utils/useAfterFastRefresh.js","webpack://muhrusdi.github.io/./node_modules/@apollo/client/react/hooks/useQuery.js","webpack://muhrusdi.github.io/./node_modules/graphql/error/syntaxError.mjs","webpack://muhrusdi.github.io/./node_modules/graphql/language/tokenKind.mjs","webpack://muhrusdi.github.io/./node_modules/graphql/language/source.mjs","webpack://muhrusdi.github.io/./node_modules/graphql/language/directiveLocation.mjs","webpack://muhrusdi.github.io/./node_modules/graphql/language/lexer.mjs","webpack://muhrusdi.github.io/./node_modules/graphql/language/parser.mjs","webpack://muhrusdi.github.io/./node_modules/graphql-tag/lib/index.js","webpack://muhrusdi.github.io/./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js"],"sourcesContent":["import { invariant } from 'ts-invariant';\nexport var DocumentType;\n\n(function (DocumentType) {\n  DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n  DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n  DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n})(DocumentType || (DocumentType = {}));\n\nvar cache = new Map();\nexport function operationName(type) {\n  var name;\n\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n\n  return name;\n}\nexport function parser(document) {\n  var cached = cache.get(document);\n  if (cached) return cached;\n  var variables, type, name;\n  __DEV__ ? invariant(!!document && !!document.kind, \"Argument of \" + document + \" passed to parser was not a valid GraphQL \" + \"DocumentNode. You may need to use 'graphql-tag' or another method \" + \"to convert your operation into a document\") : invariant(!!document && !!document.kind, 38);\n  var fragments = document.definitions.filter(function (x) {\n    return x.kind === 'FragmentDefinition';\n  });\n  var queries = document.definitions.filter(function (x) {\n    return x.kind === 'OperationDefinition' && x.operation === 'query';\n  });\n  var mutations = document.definitions.filter(function (x) {\n    return x.kind === 'OperationDefinition' && x.operation === 'mutation';\n  });\n  var subscriptions = document.definitions.filter(function (x) {\n    return x.kind === 'OperationDefinition' && x.operation === 'subscription';\n  });\n  __DEV__ ? invariant(!fragments.length || queries.length || mutations.length || subscriptions.length, \"Passing only a fragment to 'graphql' is not yet supported. \" + \"You must include a query, subscription or mutation as well\") : invariant(!fragments.length || queries.length || mutations.length || subscriptions.length, 39);\n  __DEV__ ? invariant(queries.length + mutations.length + subscriptions.length <= 1, \"react-apollo only supports a query, subscription, or a mutation per HOC. \" + (document + \" had \" + queries.length + \" queries, \" + subscriptions.length + \" \") + (\"subscriptions and \" + mutations.length + \" mutations. \") + \"You can use 'compose' to join multiple operation types to a component\") : invariant(queries.length + mutations.length + subscriptions.length <= 1, 40);\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;\n  __DEV__ ? invariant(definitions.length === 1, \"react-apollo only supports one definition per HOC. \" + document + \" had \" + (definitions.length + \" definitions. \") + \"You can use 'compose' to join multiple operation types to a component\") : invariant(definitions.length === 1, 41);\n  var definition = definitions[0];\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data';\n  }\n\n  var payload = {\n    name: name,\n    type: type,\n    variables: variables\n  };\n  cache.set(document, payload);\n  return payload;\n}","import { equal } from '@wry/equality';\nimport { invariant } from 'ts-invariant';\nimport { parser, operationName } from \"../parser/index.js\";\n\nvar OperationData = function () {\n  function OperationData(options, context) {\n    this.isMounted = false;\n    this.previousOptions = {};\n    this.context = {};\n    this.options = {};\n    this.options = options || {};\n    this.context = context || {};\n  }\n\n  OperationData.prototype.getOptions = function () {\n    return this.options;\n  };\n\n  OperationData.prototype.setOptions = function (newOptions, storePrevious) {\n    if (storePrevious === void 0) {\n      storePrevious = false;\n    }\n\n    if (storePrevious && !equal(this.options, newOptions)) {\n      this.previousOptions = this.options;\n    }\n\n    this.options = newOptions;\n  };\n\n  OperationData.prototype.unmount = function () {\n    this.isMounted = false;\n  };\n\n  OperationData.prototype.refreshClient = function () {\n    var client = this.options && this.options.client || this.context && this.context.client;\n    __DEV__ ? invariant(!!client, 'Could not find \"client\" in the context or passed in as an option. ' + 'Wrap the root component in an <ApolloProvider>, or pass an ' + 'ApolloClient instance in via options.') : invariant(!!client, 32);\n    var isNew = false;\n\n    if (client !== this.client) {\n      isNew = true;\n      this.client = client;\n      this.cleanup();\n    }\n\n    return {\n      client: this.client,\n      isNew: isNew\n    };\n  };\n\n  OperationData.prototype.verifyDocumentType = function (document, type) {\n    var operation = parser(document);\n    var requiredOperationName = operationName(type);\n    var usedOperationName = operationName(operation.type);\n    __DEV__ ? invariant(operation.type === type, \"Running a \" + requiredOperationName + \" requires a graphql \" + (requiredOperationName + \", but a \" + usedOperationName + \" was used instead.\")) : invariant(operation.type === type, 33);\n  };\n\n  return OperationData;\n}();\n\nexport { OperationData };","import { __assign, __extends } from \"tslib\";\nimport { equal } from '@wry/equality';\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType } from \"../parser/index.js\";\nimport { OperationData } from \"./OperationData.js\";\n\nvar QueryData = function (_super) {\n  __extends(QueryData, _super);\n\n  function QueryData(_a) {\n    var options = _a.options,\n        context = _a.context,\n        onNewData = _a.onNewData;\n\n    var _this = _super.call(this, options, context) || this;\n\n    _this.runLazy = false;\n    _this.previous = Object.create(null);\n\n    _this.runLazyQuery = function (options) {\n      _this.cleanup();\n\n      _this.runLazy = true;\n      _this.lazyOptions = options;\n\n      _this.onNewData();\n    };\n\n    _this.obsRefetch = function (variables) {\n      var _a;\n\n      return (_a = _this.currentObservable) === null || _a === void 0 ? void 0 : _a.refetch(variables);\n    };\n\n    _this.obsFetchMore = function (fetchMoreOptions) {\n      var _a;\n\n      return (_a = _this.currentObservable) === null || _a === void 0 ? void 0 : _a.fetchMore(fetchMoreOptions);\n    };\n\n    _this.obsUpdateQuery = function (mapFn) {\n      var _a;\n\n      return (_a = _this.currentObservable) === null || _a === void 0 ? void 0 : _a.updateQuery(mapFn);\n    };\n\n    _this.obsStartPolling = function (pollInterval) {\n      var _a;\n\n      (_a = _this.currentObservable) === null || _a === void 0 ? void 0 : _a.startPolling(pollInterval);\n    };\n\n    _this.obsStopPolling = function () {\n      var _a;\n\n      (_a = _this.currentObservable) === null || _a === void 0 ? void 0 : _a.stopPolling();\n    };\n\n    _this.obsSubscribeToMore = function (options) {\n      var _a;\n\n      return (_a = _this.currentObservable) === null || _a === void 0 ? void 0 : _a.subscribeToMore(options);\n    };\n\n    _this.onNewData = onNewData;\n    return _this;\n  }\n\n  QueryData.prototype.execute = function () {\n    this.refreshClient();\n\n    var _a = this.getOptions(),\n        skip = _a.skip,\n        query = _a.query;\n\n    if (skip || query !== this.previous.query) {\n      this.removeQuerySubscription();\n      this.removeObservable(!skip);\n      this.previous.query = query;\n    }\n\n    this.updateObservableQuery();\n    return this.getExecuteSsrResult() || this.getExecuteResult();\n  };\n\n  QueryData.prototype.executeLazy = function () {\n    return !this.runLazy ? [this.runLazyQuery, {\n      loading: false,\n      networkStatus: NetworkStatus.ready,\n      called: false,\n      data: undefined\n    }] : [this.runLazyQuery, this.execute()];\n  };\n\n  QueryData.prototype.fetchData = function () {\n    var _this = this;\n\n    var options = this.getOptions();\n    if (options.skip || options.ssr === false) return false;\n    return new Promise(function (resolve) {\n      return _this.startQuerySubscription(resolve);\n    });\n  };\n\n  QueryData.prototype.afterExecute = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.lazy,\n        lazy = _c === void 0 ? false : _c;\n\n    this.isMounted = true;\n    var options = this.getOptions();\n\n    if (this.currentObservable && !this.ssrInitiated() && !this.client.disableNetworkFetches) {\n      this.startQuerySubscription();\n    }\n\n    if (!lazy || this.runLazy) {\n      this.handleErrorOrCompleted();\n    }\n\n    this.previousOptions = options;\n    return this.unmount.bind(this);\n  };\n\n  QueryData.prototype.cleanup = function () {\n    this.removeQuerySubscription();\n    this.removeObservable(true);\n    delete this.previous.result;\n  };\n\n  QueryData.prototype.getOptions = function () {\n    var options = _super.prototype.getOptions.call(this);\n\n    if (this.lazyOptions) {\n      options.variables = __assign(__assign({}, options.variables), this.lazyOptions.variables);\n      options.context = __assign(__assign({}, options.context), this.lazyOptions.context);\n    }\n\n    if (this.runLazy) {\n      delete options.skip;\n    }\n\n    return options;\n  };\n\n  QueryData.prototype.ssrInitiated = function () {\n    return this.context && this.context.renderPromises;\n  };\n\n  QueryData.prototype.getExecuteSsrResult = function () {\n    var _a = this.getOptions(),\n        ssr = _a.ssr,\n        skip = _a.skip;\n\n    var ssrDisabled = ssr === false;\n    var fetchDisabled = this.refreshClient().client.disableNetworkFetches;\n\n    var ssrLoading = __assign({\n      loading: true,\n      networkStatus: NetworkStatus.loading,\n      called: true,\n      data: undefined,\n      stale: false,\n      client: this.client\n    }, this.observableQueryFields());\n\n    if (ssrDisabled && (this.ssrInitiated() || fetchDisabled)) {\n      this.previous.result = ssrLoading;\n      return ssrLoading;\n    }\n\n    if (this.ssrInitiated()) {\n      var result = this.getExecuteResult() || ssrLoading;\n\n      if (result.loading && !skip) {\n        this.context.renderPromises.addQueryPromise(this, function () {\n          return null;\n        });\n      }\n\n      return result;\n    }\n  };\n\n  QueryData.prototype.prepareObservableQueryOptions = function () {\n    var options = this.getOptions();\n    this.verifyDocumentType(options.query, DocumentType.Query);\n    var displayName = options.displayName || 'Query';\n\n    if (this.ssrInitiated() && (options.fetchPolicy === 'network-only' || options.fetchPolicy === 'cache-and-network')) {\n      options.fetchPolicy = 'cache-first';\n    }\n\n    return __assign(__assign({}, options), {\n      displayName: displayName,\n      context: options.context\n    });\n  };\n\n  QueryData.prototype.initializeObservableQuery = function () {\n    if (this.ssrInitiated()) {\n      this.currentObservable = this.context.renderPromises.getSSRObservable(this.getOptions());\n    }\n\n    if (!this.currentObservable) {\n      var observableQueryOptions = this.prepareObservableQueryOptions();\n      this.previous.observableQueryOptions = __assign(__assign({}, observableQueryOptions), {\n        children: void 0\n      });\n      this.currentObservable = this.refreshClient().client.watchQuery(__assign({}, observableQueryOptions));\n\n      if (this.ssrInitiated()) {\n        this.context.renderPromises.registerSSRObservable(this.currentObservable, observableQueryOptions);\n      }\n    }\n  };\n\n  QueryData.prototype.updateObservableQuery = function () {\n    if (!this.currentObservable) {\n      this.initializeObservableQuery();\n      return;\n    }\n\n    var newObservableQueryOptions = __assign(__assign({}, this.prepareObservableQueryOptions()), {\n      children: void 0\n    });\n\n    if (this.getOptions().skip) {\n      this.previous.observableQueryOptions = newObservableQueryOptions;\n      return;\n    }\n\n    if (!equal(newObservableQueryOptions, this.previous.observableQueryOptions)) {\n      this.previous.observableQueryOptions = newObservableQueryOptions;\n      this.currentObservable.setOptions(newObservableQueryOptions).catch(function () {});\n    }\n  };\n\n  QueryData.prototype.startQuerySubscription = function (onNewData) {\n    var _this = this;\n\n    if (onNewData === void 0) {\n      onNewData = this.onNewData;\n    }\n\n    if (this.currentSubscription || this.getOptions().skip) return;\n    this.currentSubscription = this.currentObservable.subscribe({\n      next: function next(_a) {\n        var loading = _a.loading,\n            networkStatus = _a.networkStatus,\n            data = _a.data;\n        var previousResult = _this.previous.result;\n\n        if (previousResult && previousResult.loading === loading && previousResult.networkStatus === networkStatus && equal(previousResult.data, data)) {\n          return;\n        }\n\n        onNewData();\n      },\n      error: function error(_error) {\n        _this.resubscribeToQuery();\n\n        if (!_error.hasOwnProperty('graphQLErrors')) throw _error;\n        var previousResult = _this.previous.result;\n\n        if (previousResult && previousResult.loading || !equal(_error, _this.previous.error)) {\n          _this.previous.error = _error;\n          onNewData();\n        }\n      }\n    });\n  };\n\n  QueryData.prototype.resubscribeToQuery = function () {\n    this.removeQuerySubscription();\n    var currentObservable = this.currentObservable;\n\n    if (currentObservable) {\n      var lastError = currentObservable.getLastError();\n      var lastResult = currentObservable.getLastResult();\n      currentObservable.resetLastResults();\n      this.startQuerySubscription();\n      Object.assign(currentObservable, {\n        lastError: lastError,\n        lastResult: lastResult\n      });\n    }\n  };\n\n  QueryData.prototype.getExecuteResult = function () {\n    var result = this.observableQueryFields();\n    var options = this.getOptions();\n\n    if (options.skip) {\n      result = __assign(__assign({}, result), {\n        data: undefined,\n        error: undefined,\n        loading: false,\n        networkStatus: NetworkStatus.ready,\n        called: true\n      });\n    } else if (this.currentObservable) {\n      var currentResult = this.currentObservable.getCurrentResult();\n      var data = currentResult.data,\n          loading = currentResult.loading,\n          partial = currentResult.partial,\n          networkStatus = currentResult.networkStatus,\n          errors = currentResult.errors;\n      var error = currentResult.error;\n\n      if (errors && errors.length > 0) {\n        error = new ApolloError({\n          graphQLErrors: errors\n        });\n      }\n\n      result = __assign(__assign({}, result), {\n        data: data,\n        loading: loading,\n        networkStatus: networkStatus,\n        error: error,\n        called: true\n      });\n\n      if (loading) {} else if (error) {\n        Object.assign(result, {\n          data: (this.currentObservable.getLastResult() || {}).data\n        });\n      } else {\n        var fetchPolicy = this.currentObservable.options.fetchPolicy;\n        var partialRefetch = options.partialRefetch;\n\n        if (partialRefetch && partial && (!data || Object.keys(data).length === 0) && fetchPolicy !== 'cache-only') {\n          Object.assign(result, {\n            loading: true,\n            networkStatus: NetworkStatus.loading\n          });\n          result.refetch();\n          return result;\n        }\n      }\n    }\n\n    result.client = this.client;\n    this.setOptions(options, true);\n    var previousResult = this.previous.result;\n    this.previous.loading = previousResult && previousResult.loading || false;\n    result.previousData = previousResult && (previousResult.data || previousResult.previousData);\n    this.previous.result = result;\n    this.currentObservable && this.currentObservable.resetQueryStoreErrors();\n    return result;\n  };\n\n  QueryData.prototype.handleErrorOrCompleted = function () {\n    if (!this.currentObservable || !this.previous.result) return;\n    var _a = this.previous.result,\n        data = _a.data,\n        loading = _a.loading,\n        error = _a.error;\n\n    if (!loading) {\n      var _b = this.getOptions(),\n          query = _b.query,\n          variables = _b.variables,\n          onCompleted = _b.onCompleted,\n          onError = _b.onError,\n          skip = _b.skip;\n\n      if (this.previousOptions && !this.previous.loading && equal(this.previousOptions.query, query) && equal(this.previousOptions.variables, variables)) {\n        return;\n      }\n\n      if (onCompleted && !error && !skip) {\n        onCompleted(data);\n      } else if (onError && error) {\n        onError(error);\n      }\n    }\n  };\n\n  QueryData.prototype.removeQuerySubscription = function () {\n    if (this.currentSubscription) {\n      this.currentSubscription.unsubscribe();\n      delete this.currentSubscription;\n    }\n  };\n\n  QueryData.prototype.removeObservable = function (andDelete) {\n    if (this.currentObservable) {\n      this.currentObservable[\"tearDownQuery\"]();\n\n      if (andDelete) {\n        delete this.currentObservable;\n      }\n    }\n  };\n\n  QueryData.prototype.observableQueryFields = function () {\n    var _a;\n\n    return {\n      variables: (_a = this.currentObservable) === null || _a === void 0 ? void 0 : _a.variables,\n      refetch: this.obsRefetch,\n      fetchMore: this.obsFetchMore,\n      updateQuery: this.obsUpdateQuery,\n      startPolling: this.obsStartPolling,\n      stopPolling: this.obsStopPolling,\n      subscribeToMore: this.obsSubscribeToMore\n    };\n  };\n\n  return QueryData;\n}(OperationData);\n\nexport { QueryData };","import { __assign } from \"tslib\";\nimport { useContext, useEffect, useReducer, useRef } from 'react';\nimport { QueryData } from \"../../data/index.js\";\nimport { useDeepMemo } from \"./useDeepMemo.js\";\nimport { getApolloContext } from \"../../context/index.js\";\nimport { useAfterFastRefresh } from \"./useAfterFastRefresh.js\";\nexport function useBaseQuery(query, options, lazy) {\n  if (lazy === void 0) {\n    lazy = false;\n  }\n\n  var context = useContext(getApolloContext());\n\n  var _a = useReducer(function (x) {\n    return x + 1;\n  }, 0),\n      tick = _a[0],\n      forceUpdate = _a[1];\n\n  var updatedOptions = options ? __assign(__assign({}, options), {\n    query: query\n  }) : {\n    query: query\n  };\n  var queryDataRef = useRef();\n  var queryData = queryDataRef.current || (queryDataRef.current = new QueryData({\n    options: updatedOptions,\n    context: context,\n    onNewData: function onNewData() {\n      if (!queryData.ssrInitiated()) {\n        Promise.resolve().then(function () {\n          return queryDataRef.current && queryDataRef.current.isMounted && forceUpdate();\n        });\n      } else {\n        forceUpdate();\n      }\n    }\n  }));\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n  var memo = {\n    options: __assign(__assign({}, updatedOptions), {\n      onError: void 0,\n      onCompleted: void 0\n    }),\n    context: context,\n    tick: tick\n  };\n  var result = useDeepMemo(function () {\n    return lazy ? queryData.executeLazy() : queryData.execute();\n  }, memo);\n  var queryResult = lazy ? result[1] : result;\n\n  if (__DEV__) {\n    useAfterFastRefresh(forceUpdate);\n  }\n\n  useEffect(function () {\n    return function () {\n      queryData.cleanup();\n      queryDataRef.current = void 0;\n    };\n  }, []);\n  useEffect(function () {\n    return queryData.afterExecute({\n      lazy: lazy\n    });\n  }, [queryResult.loading, queryResult.networkStatus, queryResult.error, queryResult.data, queryData.currentObservable]);\n  return result;\n}","import { useRef } from 'react';\nimport { equal } from '@wry/equality';\nexport function useDeepMemo(memoFn, key) {\n  var ref = useRef();\n\n  if (!ref.current || !equal(key, ref.current.key)) {\n    ref.current = {\n      key: key,\n      value: memoFn()\n    };\n  }\n\n  return ref.current.value;\n}","import { useEffect, useRef } from \"react\";\nexport function useAfterFastRefresh(effectFn) {\n  if (__DEV__) {\n    var didRefresh_1 = useRef(false);\n    useEffect(function () {\n      return function () {\n        didRefresh_1.current = true;\n      };\n    }, []);\n    useEffect(function () {\n      if (didRefresh_1.current === true) {\n        didRefresh_1.current = false;\n        effectFn();\n      }\n    }, []);\n  }\n}","import { useBaseQuery } from \"./utils/useBaseQuery.js\";\nexport function useQuery(query, options) {\n  return useBaseQuery(query, options, false);\n}","import { GraphQLError } from \"./GraphQLError.mjs\";\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport var TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { SYMBOL_TO_STRING_TAG } from \"../polyfills/symbols.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport instanceOf from \"../jsutils/instanceOf.mjs\";\n/**\n * A representation of source input to GraphQL. The `name` and `locationOffset` parameters are\n * optional, but they are useful for clients who store GraphQL documents in source files.\n * For example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might\n * be useful for `name` to be `\"Foo.graphql\"` and location to be `{ line: 40, column: 1 }`.\n * The `line` and `column` properties in `locationOffset` are 1-indexed.\n */\n\nexport var Source = /*#__PURE__*/function () {\n  function Source(body) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GraphQL request';\n    var locationOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      line: 1,\n      column: 1\n    };\n    typeof body === 'string' || devAssert(0, \"Body must be a string. Received: \".concat(inspect(body), \".\"));\n    this.body = body;\n    this.name = name;\n    this.locationOffset = locationOffset;\n    this.locationOffset.line > 0 || devAssert(0, 'line in locationOffset is 1-indexed and must be positive.');\n    this.locationOffset.column > 0 || devAssert(0, 'column in locationOffset is 1-indexed and must be positive.');\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n\n\n  _createClass(Source, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'Source';\n    }\n  }]);\n\n  return Source;\n}();\n/**\n * Test if the given value is a Source object.\n *\n * @internal\n */\n// eslint-disable-next-line no-redeclare\n\nexport function isSource(source) {\n  return instanceOf(source, Source);\n}","/**\n * The set of allowed directive location values.\n */\nexport var DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */","import { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Token } from \"./ast.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { dedentBlockStringValue } from \"./blockString.mjs\";\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport var Lexer = /*#__PURE__*/function () {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  function Lexer(source) {\n    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n\n  var _proto = Lexer.prototype;\n\n  _proto.advance = function advance() {\n    this.lastToken = this.token;\n    var token = this.token = this.lookahead();\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n  ;\n\n  _proto.lookahead = function lookahead() {\n    var token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        var _token$next; // Note: next is only mutable during parsing, so we cast to allow this.\n\n\n        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  };\n\n  return Lexer;\n}();\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = prev.end;\n\n  while (pos < bodyLength) {\n    var code = body.charCodeAt(pos);\n    var _line = lexer.line;\n\n    var _col = 1 + pos - lexer.lineStart; // SourceCharacter\n\n\n    switch (code) {\n      case 0xfeff: // <BOM>\n\n      case 9: //   \\t\n\n      case 32: //  <space>\n\n      case 44:\n        //  ,\n        ++pos;\n        continue;\n\n      case 10:\n        //  \\n\n        ++pos;\n        ++lexer.line;\n        lexer.lineStart = pos;\n        continue;\n\n      case 13:\n        //  \\r\n        if (body.charCodeAt(pos + 1) === 10) {\n          pos += 2;\n        } else {\n          ++pos;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = pos;\n        continue;\n\n      case 33:\n        //  !\n        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev);\n\n      case 35:\n        //  #\n        return readComment(source, pos, _line, _col, prev);\n\n      case 36:\n        //  $\n        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);\n\n      case 38:\n        //  &\n        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev);\n\n      case 40:\n        //  (\n        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);\n\n      case 41:\n        //  )\n        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);\n\n      case 46:\n        //  .\n        if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);\n        }\n\n        break;\n\n      case 58:\n        //  :\n        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev);\n\n      case 61:\n        //  =\n        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);\n\n      case 64:\n        //  @\n        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev);\n\n      case 91:\n        //  [\n        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);\n\n      case 93:\n        //  ]\n        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);\n\n      case 123:\n        // {\n        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);\n\n      case 124:\n        // |\n        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev);\n\n      case 125:\n        // }\n        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);\n\n      case 34:\n        //  \"\n        if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n          return readBlockString(source, pos, _line, _col, prev, lexer);\n        }\n\n        return readString(source, pos, _line, _col, prev);\n\n      case 45: //  -\n\n      case 48: //  0\n\n      case 49: //  1\n\n      case 50: //  2\n\n      case 51: //  3\n\n      case 52: //  4\n\n      case 53: //  5\n\n      case 54: //  6\n\n      case 55: //  7\n\n      case 56: //  8\n\n      case 57:\n        //  9\n        return readNumber(source, pos, code, _line, _col, prev);\n\n      case 65: //  A\n\n      case 66: //  B\n\n      case 67: //  C\n\n      case 68: //  D\n\n      case 69: //  E\n\n      case 70: //  F\n\n      case 71: //  G\n\n      case 72: //  H\n\n      case 73: //  I\n\n      case 74: //  J\n\n      case 75: //  K\n\n      case 76: //  L\n\n      case 77: //  M\n\n      case 78: //  N\n\n      case 79: //  O\n\n      case 80: //  P\n\n      case 81: //  Q\n\n      case 82: //  R\n\n      case 83: //  S\n\n      case 84: //  T\n\n      case 85: //  U\n\n      case 86: //  V\n\n      case 87: //  W\n\n      case 88: //  X\n\n      case 89: //  Y\n\n      case 90: //  Z\n\n      case 95: //  _\n\n      case 97: //  a\n\n      case 98: //  b\n\n      case 99: //  c\n\n      case 100: // d\n\n      case 101: // e\n\n      case 102: // f\n\n      case 103: // g\n\n      case 104: // h\n\n      case 105: // i\n\n      case 106: // j\n\n      case 107: // k\n\n      case 108: // l\n\n      case 109: // m\n\n      case 110: // n\n\n      case 111: // o\n\n      case 112: // p\n\n      case 113: // q\n\n      case 114: // r\n\n      case 115: // s\n\n      case 116: // t\n\n      case 117: // u\n\n      case 118: // v\n\n      case 119: // w\n\n      case 120: // x\n\n      case 121: // y\n\n      case 122:\n        // z\n        return readName(source, pos, _line, _col, prev);\n    }\n\n    throw syntaxError(source, pos, unexpectedCharacterMessage(code));\n  }\n\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Token(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n\n  if (code === 46 || isNameStart(code)) {\n    throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Token(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Token(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Token(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n} // _ A-Z a-z\n\n\nfunction isNameStart(code) {\n  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;\n}","import { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Kind } from \"./kinds.mjs\";\nimport { Location } from \"./ast.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { Source, isSource } from \"./source.mjs\";\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var _this$_options2;\n\n    if (!this.expectOptionalKeyword('implements')) {\n      return [];\n    }\n\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {\n      var types = []; // Optional leading ampersand\n\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));\n\n      return types;\n    }\n\n    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3; // Legacy support for the SDL?\n\n\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n  ;\n\n  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}","import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\n\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\nfunction processFragments(ast) {\n  var seenKeys = new Set();\n  var definitions = [];\n  ast.definitions.forEach(function (fragmentDefinition) {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n      var sourceKeySet = fragmentSourceMap.get(fragmentName);\n\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set());\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n  return __assign(__assign({}, ast), {\n    definitions: definitions\n  });\n}\n\nfunction stripLoc(doc) {\n  var workSet = new Set(doc.definitions);\n  workSet.forEach(function (node) {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(function (key) {\n      var value = node[key];\n\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n  var loc = doc.loc;\n\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source) {\n  var cacheKey = normalize(source);\n\n  if (!docCache.has(cacheKey)) {\n    var parsed = parse(source, {\n      experimentalFragmentVariables: experimentalFragmentVariables\n    });\n\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n\n    docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n  }\n\n  return docCache.get(cacheKey);\n}\n\nexport function gql(literals) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  var result = literals[0];\n  args.forEach(function (arg, i) {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n\n    result += literals[i + 1];\n  });\n  return parseDocument(result);\n}\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\nvar extras = {\n  gql: gql,\n  resetCaches: resetCaches,\n  disableFragmentWarnings: disableFragmentWarnings,\n  enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n\n(function (gql_1) {\n  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\n\ngql[\"default\"] = gql;\nexport default gql;","export default function _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  strings.raw = raw;\n  return strings;\n}"],"names":["DocumentType","cache","Map","operationName","type","name","Query","Mutation","Subscription","QueryData","_super","_a","options","context","onNewData","_this","call","this","runLazy","previous","Object","create","runLazyQuery","cleanup","lazyOptions","obsRefetch","variables","currentObservable","refetch","obsFetchMore","fetchMoreOptions","fetchMore","obsUpdateQuery","mapFn","updateQuery","obsStartPolling","pollInterval","startPolling","obsStopPolling","stopPolling","obsSubscribeToMore","subscribeToMore","prototype","execute","refreshClient","getOptions","skip","query","removeQuerySubscription","removeObservable","updateObservableQuery","getExecuteSsrResult","getExecuteResult","executeLazy","loading","networkStatus","called","data","undefined","fetchData","ssr","Promise","resolve","startQuerySubscription","afterExecute","_c","lazy","isMounted","ssrInitiated","client","disableNetworkFetches","handleErrorOrCompleted","previousOptions","unmount","bind","result","renderPromises","ssrDisabled","fetchDisabled","ssrLoading","stale","observableQueryFields","addQueryPromise","prepareObservableQueryOptions","verifyDocumentType","displayName","fetchPolicy","initializeObservableQuery","getSSRObservable","observableQueryOptions","children","watchQuery","registerSSRObservable","newObservableQueryOptions","setOptions","catch","currentSubscription","subscribe","next","previousResult","error","_error","resubscribeToQuery","hasOwnProperty","lastError","getLastError","lastResult","getLastResult","resetLastResults","assign","currentResult","getCurrentResult","partial","errors","length","graphQLErrors","partialRefetch","keys","previousData","resetQueryStoreErrors","_b","onCompleted","onError","unsubscribe","andDelete","OperationData","newOptions","storePrevious","__DEV__","isNew","document","operation","cached","get","kind","fragments","definitions","filter","x","queries","mutations","subscriptions","definition","variableDefinitions","payload","value","set","parser","requiredOperationName","usedOperationName","useBaseQuery","useContext","useReducer","tick","forceUpdate","updatedOptions","queryDataRef","useRef","queryData","current","then","memoFn","key","ref","memo","queryResult","effectFn","didRefresh_1","useEffect","useAfterFastRefresh","useQuery","syntaxError","source","position","description","GraphQLError","concat","freeze","SOF","EOF","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","NAME","INT","FLOAT","STRING","BLOCK_STRING","COMMENT","_defineProperties","target","props","i","descriptor","enumerable","configurable","writable","defineProperty","Source","body","arguments","locationOffset","line","column","devAssert","inspect","Constructor","protoProps","staticProps","DirectiveLocation","QUERY","MUTATION","SUBSCRIPTION","FIELD","FRAGMENT_DEFINITION","FRAGMENT_SPREAD","INLINE_FRAGMENT","VARIABLE_DEFINITION","SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","Lexer","startOfFileToken","lastToken","token","lineStart","_proto","advance","lookahead","_token$next","readToken","printCharCode","code","isNaN","JSON","stringify","String","fromCharCode","toString","toUpperCase","slice","lexer","prev","bodyLength","pos","end","charCodeAt","_line","_col","readComment","readBlockString","readString","readNumber","readName","unexpectedCharacterMessage","col","start","firstCode","isFloat","readDigits","isNameStart","a","b","c","d","chunkStart","charCode","char2hex","invalidSequence","rawValue","Parser","sourceObj","instanceOf","isSource","_lexer","_options","parseName","expectToken","loc","parseDocument","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","peekDescription","unexpected","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","variable","parseVariable","parseTypeReference","defaultValue","expectOptionalToken","parseValueLiteral","selections","parseSelection","parseFragment","parseField","alias","nameOrAlias","parseArguments","isConst","item","parseConstArgument","parseArgument","hasTypeCondition","expectOptionalKeyword","parseFragmentName","typeCondition","parseNamedType","_this$_options","expectKeyword","experimentalFragmentVariables","parseList","parseObject","parseStringLiteral","block","values","any","_this2","fields","parseObjectField","push","parseDirective","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","_this$_options2","allowLegacySDLImplementsInterfaces","types","delimitedMany","_this$_options3","allowLegacySDLEmptyFields","parseFieldDefinition","args","parseArgumentDefs","parseInputValueDef","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","locations","parseDirectiveLocations","parseDirectiveLocation","startToken","_this$_options4","noLocation","getTokenKindDesc","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes","delimiterKind","isPunctuatorTokenKind","docCache","fragmentSourceMap","printFragmentWarnings","normalize","string","replace","trim","processFragments","ast","seenKeys","Set","forEach","fragmentDefinition","fragmentName","sourceKey","substring","sourceKeySet","has","console","warn","add","cacheKey","parsed","parse","Error","doc","workSet","node","endToken","stripLoc","gql","literals","_i","arg","gql_1","extras","clear","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","_taggedTemplateLiteralLoose","strings","raw"],"sourceRoot":""}